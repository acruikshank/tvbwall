<!DOCTYPE html>
<html lang="en">
  <head>
    <title>TVB Wall</title>
    <meta charset="utf-8">
    <style>
      body {
        margin: 0px;
        background-color: #333;
        overflow: hidden;
      }

      #offscreen { display:none; }

      #edit-script {
        position: absolute;
        top: 55%;
        left: 0;
        bottom: 0;
        right: 0;
        z-index: 1;
        transition: transform .5s ease;
        transform: translate(0, 100%);
      }

      .edit #edit-script {
        transform: translate(0, 0);        
      }

      #edit-script button {
        position: absolute;
        z-index: 2;
        border-width: 0;
        background-color: rgba(0,0,0,.1);
        height: 8%;
        border-radius: 4px;
        font-size: 24px;
        font-family: Helvetica Neue;
        font-weight: 200;
        letter-spacing: 2px;
        cursor: pointer;
        color: #333;
        transition: background-color .25s linear;
      }
      #edit-script button:hover {
        background-color: rgba(255,255,200,.4);
        font-weight: 200;
      }

      #run {
        bottom: 1%;
        right: 1%;        
        width: 12%;
      }

      #edit {
        left: 1%;
        top: -10%;
        width: 8%;
      }

      #editor {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 14%;
        background: rgba(0,0,0,.08);
        border-radius: 0 3px 0 0;
      }
      #editor .ace_gutter {
        color: #999;
      }
      #editor .ace_scroller {
        box-shadow: inset 0 0 5px rgba(0,0,0,.5);
      }
      #editor .ace_indent-guide {
        opacity:0;
      }
      #edit-script input {
        background: rgba(0,0,0,.08);
        border-radius: 3px;
        border: none;
        box-shadow: inset 0 0 5px rgba(0,0,0,.5);
        box-sizing: border-box;
        padding: 15px 12px;
        position: absolute;
        right: 1%;
        width: 12%;
        margin: 0;
        font-size: 18px;
        font-family: Helvetica Neue;
        font-weight: 200;
        letter-spacing: 1px;
        color: #999;
      }
      #edit-script input:focus {
        outline: none;
      }

      #name {
        top: 0;
      }

      #author {
        top: 60px;
      }
    </style>
    <script src="http://ajax.googleapis.com/ajax/libs/threejs/r67/three.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/ace.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/processing.js/1.4.8/processing.min.js"></script>
    <script src="droid_sans_regular.typeface.js"></script>
  </head>
  <body>
    <canvas id="offscreen" height="8" width="48"></canvas>
    <div id="edit-script">
      <button id="edit">edit</button>
      <input id="name" placeholder="title"/>
      <input id="author" placeholder="author"/>
      <button id="run">start</button>
      <div id="editor"></div>
    </div>
    <script>

  var renderer, camera, ground, scene, editor;
  var buttonColors = [[],[],[],[],[],[],[],[],[]];
  var buttons = [];

  var cameraOffset = {x:0, y:-50, z:-2.5};
  var cameraLookAt = {x:0, y:0, z:-5};
  var outline = .08;

  init();
  addGeometry();
  requestAnimationFrame(render);
  startSketch();

  function addGeometry() {
    var wallMaterial = new THREE.MeshBasicMaterial(  );
    wallMaterial.color.setHSL( 0.095, .025, 0.25 );
    wallMaterial.wireframe = true;
    wallMaterial.wireframeLinewidth = .5;

    var backWall = new THREE.BoxGeometry(72 - .9*16, 16, 16);
    translateGeometry( backWall, .9*8, 16, 0);
    addMesh(new THREE.Mesh(backWall, wallMaterial ))

    var backWallSeparator = new THREE.BoxGeometry(72 - .9*16, 1.5, 4);
    translateGeometry( backWallSeparator, .9*8, 8, 2);
    addMesh(new THREE.Mesh(backWallSeparator, wallMaterial ))

    var backWallTop = new THREE.BoxGeometry(72 - .9*16, 1, 1);
    rotateGeometry( backWallTop, Math.PI/4, 0, 0 );
    translateGeometry( backWallTop, .9*8, 8, 8);
    addMesh(new THREE.Mesh(backWallTop, wallMaterial ))

    var topMass = new THREE.BoxGeometry(72, 32, 16);
    translateGeometry( topMass, 0, 8, 16);
    addMesh(new THREE.Mesh(topMass, wallMaterial ))

    var door = new THREE.BoxGeometry(.9*16, 16, 16);
    translateGeometry( door, -(72-.9*16)/2, 32, 0);
    addMesh(new THREE.Mesh(door, wallMaterial ))

    var planter = new THREE.BoxGeometry(72 - .9*16, 8, 1);
    translateGeometry( planter, .9*8, 4, -8);
    addMesh(new THREE.Mesh(planter, wallMaterial ));

    for (var i=0; i<6; i++) {
      var column = new THREE.BoxGeometry(.75, .75, 32);
      rotateGeometry(column, 0, 0, Math.PI/4 );
      translateGeometry( column, -36 + i*72/5, -8, 8);
      addMesh(new THREE.Mesh(column, wallMaterial ));

      column = new THREE.BoxGeometry(.75, .75, 32);
      rotateGeometry(column, 0, 0, Math.PI/4 );
      translateGeometry( column, -36 + i*72/5, 8, 8);
      addMesh(new THREE.Mesh(column, wallMaterial ));

      column = new THREE.BoxGeometry(.75, 16, .75);
      rotateGeometry(column, 0, Math.PI/4, 0 );
      translateGeometry( column, -36 + i*72/5, 0, 8);
      addMesh(new THREE.Mesh(column, wallMaterial ));
    }

    var textProperties = {
      size: .6,
      height: .01,
      curveSegments: 4,

      font: 'droid sans',
      style: 'normal',
      weight: 'normal'
    };
    var textMaterial = new THREE.MeshBasicMaterial( {color:0xffffff, transparent:true, opacity:.5});
    var text = new THREE.TextGeometry('Causeway Challenge Proposal', textProperties );
    rotateGeometry(text, Math.PI/2, 0, 0);
    translateGeometry(text, -18, -12, 7)
    scene.add(new THREE.Mesh(text, textMaterial));

    text = new THREE.TextGeometry('Public Gaming Wall', textProperties );
    rotateGeometry(text, Math.PI/2, 0, 0);
    translateGeometry(text, -19, -3, 7.5)
    scene.add(new THREE.Mesh(text, textMaterial));

    [-20.5, -6, 8.5].forEach(function(xOffset, k){
      for (var i=0; i<16; i++) {
        for (var j=0; j<8; j++) {
          var material = new THREE.MeshBasicMaterial( { color:0xffffff });
          buttonColors[j][i + 16*k] = material;
          var buttonRadius = .2;
          ellipseGeometry = new THREE.CylinderGeometry(buttonRadius, buttonRadius, .01,8);
          translateGeometry(ellipseGeometry, i * .8 + xOffset, 8, (7-j) * .8 - 6.5);
          var buttonMesh = new THREE.Mesh(ellipseGeometry, material);

          buttonMesh.xIndex = i + 16*k;
          buttonMesh.yIndex = j;
          buttons.push( buttonMesh );
          scene.add(buttonMesh);
        }
      }
    })
  }

  function init() {
    renderer = new THREE.WebGLRenderer( {alpha: true} );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.shadowMapEnabled = true;
    document.body.appendChild( renderer.domElement );

    camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 200 );
    camera.up = new THREE.Vector3( 0, 0, 1 );
    setCamera( cameraOffset.x, cameraOffset.y, cameraOffset.z, cameraLookAt.x, cameraLookAt.y, cameraLookAt.z );

    scene = new THREE.Scene();

    scene.fog = new THREE.Fog( 0xffffff, 1, 200 );
    scene.fog.color.setHSL( 0.6, 0, .2 );

    var light = new THREE.DirectionalLight(0x333333);
    light.position.set(-10,-30,10);
    light.rotation.x = light.rotation.y = light.rotation.z = 0;
    light.target.position.set(0.0,0.0,10.0);
    light.target.updateMatrixWorld();
    light.castShadow = true;
    light.shadowMapWidth = 4096;
    light.shadowMapHeight = 4096;

    var d = 200;
    light.shadowCameraLeft = -d;
    light.shadowCameraRight = d;
    light.shadowCameraTop = d;
    light.shadowCameraBottom = -d;

    scene.add(light);

    var hemiLight = new THREE.HemisphereLight( 0x999999, 0x999999, 0.6 );
    hemiLight.color.setHSL( 0.095, .25, 0.8 );
    hemiLight.groundColor.setHSL( 0.095, .05, 0.8 );
    hemiLight.position.set( 0, 500, 0 );
    scene.add( hemiLight );


    // GROUND
    var groundGeo = new THREE.PlaneGeometry( 10000, 10000 );
    var groundMat = new THREE.MeshPhongMaterial( { ambient: 0x999999, color: 0x999999, specular: 0x999999 } );
    groundMat.color.setHSL( 0.095, .0, 0.8 );

    ground = new THREE.Mesh( groundGeo, groundMat );
    scene.add( ground );

    ground.receiveShadow = true;

    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    renderer.shadowMapCullFace = THREE.CullFaceBack;

    editor = ace.edit("editor");
    editor.setTheme("ace/theme/ambiance");
    editor.getSession().setMode("ace/mode/java");
    editor.setShowPrintMargin(false);
    editor.getSession().setUseSoftTabs(true);
    editor.setFontSize(16);
    editor.commands.addCommand({
        name: 'runScript',
        bindKey: {win: 'Ctrl-Alt-Enter',  mac: 'Ctrl-Alt-Enter'},
        exec: startSketch
    });
    editor.renderer.setPadding(15);
    editor.renderer.setScrollMargin(15);
    setTimeout(function() {
      editor.focus();
      editor.clearSelection();
    }, 500);

    if (localStorage['processing-script'])
      editor.setValue(localStorage['processing-script']);

    window.addEventListener( 'resize', onWindowResize, false );
    document.body.addEventListener( 'mousemove', onMouseMove, false );
    document.body.addEventListener( 'click', onMouseClick, false );
    document.getElementById('run').onclick = startSketch
    document.getElementById('edit').onclick = toggleEdit;
  }

  function toggleEdit() {
    if (document.body.getAttribute('class') == 'edit') {
      document.getElementById('edit').innerHTML = 'edit';
      document.body.setAttribute('class','');
    } else {
      document.getElementById('edit').innerHTML = 'close';
      document.body.setAttribute('class','edit');      
    }
  }

  function banner(txt, next) {
    var processing = Processing.getInstanceById('offscreen');
    if (! processing)
      processing = new Processing(document.getElementById('offscreen'));

    var font = processing.loadFont('verdana');
    processing.textFont(font,10);

    // var ctx = document.getElementById('offscreen').getContext('2d');
    // ctx.font = '10px verdana';
    var width = processing.textWidth(txt);
    var x = 52;
    // ctx.fillStyle = 'rgba(255,255,255,.5)';
    var interval = setInterval(function() {
      processing.background(0);
      processing.fill(255);
      processing.text(txt, x,8);
      // ctx.clearRect(0,0,48,8);
      // ctx.fillText(txt,x,8.0);
      x -= .5;
      if (x + width + 8 < 0) {
        clearInterval(interval);
        next();
      }
    },50);
  }

  function startSketch() {
    var script = editor.getValue();

    localStorage['processing-script'] = script;
    var oldInstance = Processing.getInstanceById('offscreen');
    if (oldInstance) oldInstance.noLoop();
    if ( document.getElementById('name').value ) {
      var txt = document.getElementById('name').value.toUpperCase();
      if (document.getElementById('author').value)
        txt += ' BY ' + document.getElementById('author').value.toUpperCase()
      banner(txt, function() {
        new Processing(document.getElementById('offscreen'), script);
      });
    } else {
      new Processing(document.getElementById('offscreen'), script);
    }
  }

  function onMouseMove( e ) {    
    var windowWidth = document.body.offsetWidth;
    var windowHeight = document.body.offsetHeight;
    var xAngle = .2 * Math.PI * (e.clientX - windowWidth / 2) / windowWidth;

    var x = -cameraOffset.y * Math.sin(xAngle) + cameraOffset.x;
    var y = cameraOffset.y * Math.cos(xAngle);
    var z = 5 * ((e.clientY) / document.body.offsetWidth) + cameraOffset.z;
    setCamera( x, y, z, cameraLookAt.x, cameraLookAt.y, cameraLookAt.z );
  }

  function onMouseClick( e ) {
    var processing = Processing.getInstanceById('offscreen');
    if ( ! processing.mouseClicked ) return;

    var windowWidth = document.body.offsetWidth;
    var windowHeight = document.body.offsetHeight;
    var mouseVector = new THREE.Vector3();
    var projector = new THREE.Projector();
    mouseVector.x = 2 * (e.clientX / windowWidth) - 1;
    mouseVector.y = 1 - 2 * (e.clientY / windowHeight);

    var raycaster = projector.pickingRay( mouseVector, camera );

    var intersects = raycaster.intersectObjects( buttons );
    if (intersects.length > 0) {
      var ctx = document.getElementById('offscreen').getContext('2d');
      intersects.forEach(function(button) {
        processing.mouseX = button.object.xIndex;
        processing.mouseY = button.object.yIndex;
        processing.mouseClicked();
      })
    }

  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );
  }


  function render() {
    var canvasData = document.getElementById('offscreen').getContext('2d').getImageData(0,0,48,8).data;
    for (var i=0; i<48; i++) {
      for (var j=0; j<8; j++) {
        var index = (j*48 + i)*4;
        buttonColors[j][i].color.setRGB( canvasData[index] / 255, canvasData[index+1] / 255, canvasData[index+2] / 255 );
      }
    }

    renderer.render( scene, camera );    
    requestAnimationFrame(render);
  }

  function addMesh( mesh, meshName ) {
    scene.add(mesh);

    if (! mesh.geometry.boundingBox)
      mesh.geometry.computeBoundingBox();
    var bounds = mesh.geometry.boundingBox.clone();
    var size = bounds.max.sub(bounds.min);
    var center = bounds.min.clone().add( size.multiplyScalar(.5) );
    var scale = new THREE.Vector3(1,1,1) // .divide(size).multiplyScalar(outline).addScalar(1);
    scale.x = Math.abs(scale.x);
    scale.y = Math.abs(scale.y);
    scale.z = Math.abs(scale.z);


    var transform = new THREE.Matrix4()
      .multiply(new THREE.Matrix4().setPosition(center))
      .multiply(new THREE.Matrix4().scale(scale))
      .multiply(new THREE.Matrix4().setPosition(center.multiplyScalar(-1)))

    var outlineMesh = new THREE.Mesh( mesh.geometry, new THREE.MeshBasicMaterial( { color: 0x555555, transparent:true, opacity:.6, side: THREE.BackSide } ));
    outlineMesh.applyMatrix(transform);

    scene.add(outlineMesh);

    ground.position.z = Math.min(ground.position.z, bounds.min.z - outline * size.z);
  }

  function setCamera(x,y,z, atX, atY, atZ) {
    camera.position.x = x;
    camera.position.y = y;
    camera.position.z = z;
    camera.lookAt( new THREE.Vector3(atX,atY,atZ) );
  }

function translateGeometry( g, x, y, z ) {
  matrix = new THREE.Matrix4().makeTranslation(x,y,z);
  g.applyMatrix(matrix);
}

function rotateGeometry( g, x, y, z ) {
  var matrix;
  if (x)
    matrix = new THREE.Matrix4().makeRotationX(x);
  if (y)
    matrix = (matrix||new THREE.Matrix4()).makeRotationY(y);
  if (z)
    matrix = (matrix||new THREE.Matrix4()).makeRotationZ(z);
  if (matrix)
    g.applyMatrix(matrix);
}

function scaleGeometry( g, x, y, z ) {
  matrix = new THREE.Matrix4().makeScale(x,y,z);
  g.applyMatrix(matrix);
}

    </script>
  </body>
</html>